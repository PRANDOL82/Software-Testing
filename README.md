# Software-Testing
Reflection
In this course, I focused on building and testing a contact management service, which helped me develop a deeper understanding of software testing, automation, and quality assurance. These projects challenged me to ensure that my code was not only functional but also secure and maintainable.

To ensure functionality and security, I implemented thorough unit tests using JUnit. These tests helped me catch bugs early and validate that each method behaved as expected under various conditions. I also followed best practices such as input validation, encapsulation, and exception handling to safeguard against common vulnerabilities and ensure robust performance.

Interpreting user needs was a key part of the development process. I began by analyzing the project requirements and identifying core functionalities that users would expect—such as adding, updating, and deleting contacts. I translated these needs into clear, testable features and used feedback from test results to refine the implementation.

When designing software, I take a modular and iterative approach. I start by outlining the main components and their responsibilities, then build each part incrementally while continuously testing and refining. This method allows me to adapt quickly to changes and maintain a clean, organized codebase.

Overall, these projects have strengthened my ability to write reliable, testable, and user-focused software. They’ve also reinforced the importance of automated testing in delivering high-quality applications and prepared me to apply these principles in real-world development environments.
